<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>–¢–µ—Å—Ç —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ä–µ—á–∏</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
      }

      .container {
        background: white;
        border-radius: 20px;
        padding: 40px;
        max-width: 600px;
        width: 100%;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      }

      h1 {
        color: #333;
        margin-bottom: 10px;
        font-size: 28px;
      }

      .subtitle {
        color: #666;
        margin-bottom: 30px;
        font-size: 14px;
      }

      .auth-section {
        margin-bottom: 30px;
        padding: 20px;
        background: #f8f9fa;
        border-radius: 10px;
      }

      .auth-section label {
        display: block;
        margin-bottom: 8px;
        color: #555;
        font-weight: 500;
      }

      .auth-section input {
        width: 100%;
        padding: 12px;
        border: 2px solid #e1e4e8;
        border-radius: 8px;
        font-size: 14px;
        margin-bottom: 10px;
      }

      .auth-section input:focus {
        outline: none;
        border-color: #667eea;
      }

      .record-section {
        text-align: center;
        margin: 30px 0;
      }

      .record-button {
        width: 120px;
        height: 120px;
        border-radius: 50%;
        border: none;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        font-size: 48px;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
      }

      .record-button:hover {
        transform: scale(1.1);
        box-shadow: 0 15px 40px rgba(102, 126, 234, 0.6);
      }

      .record-button:active {
        transform: scale(0.95);
      }

      .record-button.recording {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        animation: pulse 1.5s infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      .status {
        margin-top: 15px;
        color: #666;
        font-size: 14px;
      }

      .file-upload {
        margin: 30px 0;
        padding: 20px;
        border: 2px dashed #667eea;
        border-radius: 10px;
        text-align: center;
        cursor: pointer;
        transition: all 0.3s;
      }

      .file-upload:hover {
        background: #f8f9fa;
        border-color: #764ba2;
      }

      .file-upload input {
        display: none;
      }

      .button {
        width: 100%;
        padding: 15px;
        border: none;
        border-radius: 10px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
        margin-top: 10px;
      }

      .button:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
      }

      .button:disabled {
        background: #ccc;
        cursor: not-allowed;
        transform: none;
      }

      .result {
        margin-top: 30px;
        padding: 20px;
        background: #f8f9fa;
        border-radius: 10px;
        border-left: 4px solid #667eea;
      }

      .result h3 {
        color: #333;
        margin-bottom: 10px;
      }

      .result p {
        color: #555;
        line-height: 1.6;
      }

      .error {
        background: #fff5f5;
        border-left-color: #f5576c;
      }

      .error h3 {
        color: #f5576c;
      }

      .hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üé§ –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏</h1>
      <p class="subtitle">–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ Gigachat Speech-to-Text API</p>

      <div class="auth-section">
        <label for="token">JWT —Ç–æ–∫–µ–Ω:</label>
        <input type="text" id="token" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ –≤–∞—à JWT —Ç–æ–∫–µ–Ω" />
        <div
          style="
            margin-top: 10px;
            padding: 10px;
            background: #d1ecf1;
            border-radius: 5px;
            font-size: 12px;
            color: #0c5460;
          "
        >
          <strong>‚ÑπÔ∏è –¢—Ä–µ–±–æ–≤–∞–Ω–∏–µ:</strong> —Å–µ—Ä–≤–∏—Å –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Ç–æ–ª—å–∫–æ —Ñ–∞–π–ª—ã OGG
          (Opus), WAV –∏–ª–∏ MP3.<br />
          –ü—Ä–∏ –∑–∞–ø–∏—Å–∏ —Å –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º OGG/Opus ‚Äî –µ—Å–ª–∏ –±—Ä–∞—É–∑–µ—Ä –Ω–µ
          –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —ç—Ç–æ—Ç —Ñ–æ—Ä–º–∞—Ç, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≥–æ—Ç–æ–≤—ã–π —Ñ–∞–π–ª.
        </div>
      </div>

      <div class="record-section">
        <button class="record-button" id="recordBtn">üéôÔ∏è</button>
        <div class="status" id="status">–ù–∞–∂–º–∏—Ç–µ –¥–ª—è –∑–∞–ø–∏—Å–∏</div>
      </div>

      <div class="file-upload" id="fileUpload">
        <input
          type="file"
          id="fileInput"
          accept="audio/ogg,audio/wav,audio/mpeg,.ogg,.wav,.mp3"
        />
        <p>üìÅ –ò–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ –∞—É–¥–∏–æ—Ñ–∞–π–ª</p>
        <small style="color: #999">–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è: OGG (Opus), WAV, MP3</small>
      </div>

      <button class="button" id="uploadBtn" disabled>
        –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ
      </button>

      <div class="result hidden" id="result"></div>
    </div>

    <script>
      let mediaRecorder;
      let audioChunks = [];
      let audioBlob = null;

      const preferredRecorderMime = "audio/ogg;codecs=opus";
      const fallbackRecorderMime = "audio/webm;codecs=opus";
      const defaultWaveMime = "audio/wav";

      const recordBtn = document.getElementById("recordBtn");
      const status = document.getElementById("status");
      const fileInput = document.getElementById("fileInput");
      const fileUpload = document.getElementById("fileUpload");
      const uploadBtn = document.getElementById("uploadBtn");
      const result = document.getElementById("result");
      const tokenInput = document.getElementById("token");

      // –ó–∞–ø–∏—Å—å —Å –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞
      recordBtn.addEventListener("click", async () => {
        if (!mediaRecorder || mediaRecorder.state === "inactive") {
          try {
            const stream = await navigator.mediaDevices.getUserMedia({
              audio: {
                channelCount: 1,
                sampleRate: 16000,
              },
            });

            const mimeType = pickRecorderMime();
            if (!mimeType) {
              showError(
                "–ë—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∑–∞–ø–∏—Å—å –≤ OGG/Opus. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ—Å–ª–µ–¥–Ω—é—é –≤–µ—Ä—Å–∏—é Chrome –∏–ª–∏ Edge –ª–∏–±–æ –∑–∞–≥—Ä—É–∑–∏—Ç–µ –≥–æ—Ç–æ–≤—ã–π —Ñ–∞–π–ª."
              );
              return;
            }

            mediaRecorder = new MediaRecorder(stream, { mimeType });

            mediaRecorder.ondataavailable = (event) => {
              audioChunks.push(event.data);
            };

            mediaRecorder.onstop = async () => {
              const recordedMime =
                mediaRecorder.mimeType || mimeType || fallbackRecorderMime;
              let blob = new Blob(audioChunks, { type: recordedMime });
              audioChunks = [];

              if (!recordedMime.includes("ogg")) {
                status.textContent = "–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –∑–∞–ø–∏—Å–∏ –≤ WAV...";
                try {
                  blob = await transcodeToWav(blob);
                  status.textContent = "–ó–∞–ø–∏—Å—å –≥–æ—Ç–æ–≤–∞ (—Ñ–æ—Ä–º–∞—Ç WAV)";
                } catch (e) {
                  showError("–ù–µ —É–¥–∞–ª–æ—Å—å –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –∑–∞–ø–∏—Å—å: " + e.message);
                  stream.getTracks().forEach((track) => track.stop());
                  recordBtn.classList.remove("recording");
                  uploadBtn.disabled = true;
                  mediaRecorder = null;
                  return;
                }
              } else {
                status.textContent = "–ó–∞–ø–∏—Å—å –≥–æ—Ç–æ–≤–∞ (—Ñ–æ—Ä–º–∞—Ç OGG/Opus)";
              }

              audioBlob = blob;
              uploadBtn.disabled = false;
              recordBtn.classList.remove("recording");

              stream.getTracks().forEach((track) => track.stop());
            };

            mediaRecorder.start();
            recordBtn.classList.add("recording");
            recordBtn.textContent = "‚èπÔ∏è";
            status.textContent = "–ò–¥–µ—Ç –∑–∞–ø–∏—Å—å... –ù–∞–∂–º–∏—Ç–µ –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏";
          } catch (error) {
            showError("–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É: " + error.message);
          }
        } else {
          mediaRecorder.stop();
          recordBtn.textContent = "üéôÔ∏è";
        }
      });

      // –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞
      fileUpload.addEventListener("click", () => fileInput.click());

      fileInput.addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (file) {
          if (!isAllowedFile(file)) {
            showError("–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª –≤ —Ñ–æ—Ä–º–∞—Ç–µ OGG (Opus), WAV –∏–ª–∏ MP3");
            uploadBtn.disabled = true;
            audioBlob = null;
            return;
          }
          audioBlob = file;
          uploadBtn.disabled = false;
          status.textContent = `–§–∞–π–ª –≤—ã–±—Ä–∞–Ω: ${file.name}`;
        }
      });

      // –û—Ç–ø—Ä–∞–≤–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä
      uploadBtn.addEventListener("click", async () => {
        const token = tokenInput.value.trim();

        if (!token) {
          showError("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ JWT —Ç–æ–∫–µ–Ω");
          return;
        }

        if (!audioBlob) {
          showError("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–ø–∏—à–∏—Ç–µ –∏–ª–∏ –∑–∞–≥—Ä—É–∑–∏—Ç–µ –∞—É–¥–∏–æ—Ñ–∞–π–ª");
          return;
        }

        uploadBtn.disabled = true;
        uploadBtn.textContent = "–û–±—Ä–∞–±–æ—Ç–∫–∞...";

        try {
          const formData = new FormData();
          let filename = "audio.ogg";
          const blobType = (audioBlob.type || "").toLowerCase();

          if (blobType.includes("wav")) filename = "audio.wav";
          else if (blobType.includes("mp3") || blobType.includes("mpeg"))
            filename = "audio.mp3";
          else if (blobType.includes("ogg")) filename = "audio.ogg";
          else if (audioBlob.name) {
            filename = inferFilename(audioBlob.name);
          }

          formData.append("audio", audioBlob, filename);

          const response = await fetch("/api/v1/speech/recognize", {
            method: "POST",
            headers: {
              Authorization: `Bearer ${token}`,
            },
            body: formData,
          });

          const data = await response.json();

          if (response.ok) {
            showResult(data.text);
          } else {
            showError(data.error || data.message || "–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–∏");
          }
        } catch (error) {
          showError("–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è: " + error.message);
        } finally {
          uploadBtn.disabled = false;
          uploadBtn.textContent = "–û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ";
        }
      });

      function isAllowedFile(file) {
        const type = (file.type || "").toLowerCase();
        if (
          type.includes("ogg") ||
          type.includes("wav") ||
          type.includes("mpeg") ||
          type.includes("mp3")
        ) {
          return true;
        }
        const name = (file.name || "").toLowerCase();
        return (
          name.endsWith(".ogg") ||
          name.endsWith(".wav") ||
          name.endsWith(".mp3")
        );
      }

      function inferFilename(name) {
        const lower = (name || "").toLowerCase();
        if (lower.endsWith(".wav")) return "audio.wav";
        if (lower.endsWith(".mp3")) return "audio.mp3";
        if (lower.endsWith(".ogg")) return "audio.ogg";
        return "audio.ogg";
      }

      function pickRecorderMime() {
        if (MediaRecorder.isTypeSupported(preferredRecorderMime)) {
          return preferredRecorderMime;
        }
        if (MediaRecorder.isTypeSupported(fallbackRecorderMime)) {
          return fallbackRecorderMime;
        }
        return null;
      }

      async function transcodeToWav(blob) {
        const arrayBuffer = await blob.arrayBuffer();
        const audioCtx = new (window.AudioContext ||
          window.webkitAudioContext)();
        const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);

        const numChannels = audioBuffer.numberOfChannels;
        const length = audioBuffer.length;
        const sampleRate = audioBuffer.sampleRate;

        const interleaved = new Float32Array(length * numChannels);
        let offset = 0;
        for (let i = 0; i < length; i++) {
          for (let ch = 0; ch < numChannels; ch++) {
            interleaved[offset++] = audioBuffer.getChannelData(ch)[i];
          }
        }

        const wavBuffer = encodeWAV(interleaved, sampleRate, numChannels);
        return new Blob([wavBuffer], { type: defaultWaveMime });
      }

      function encodeWAV(samples, sampleRate, numChannels) {
        const bytesPerSample = 2;
        const blockAlign = numChannels * bytesPerSample;
        const dataLength = samples.length * bytesPerSample;
        const buffer = new ArrayBuffer(44 + dataLength);
        const view = new DataView(buffer);

        writeString(view, 0, "RIFF");
        view.setUint32(4, 36 + dataLength, true);
        writeString(view, 8, "WAVE");
        writeString(view, 12, "fmt ");
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, numChannels, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * blockAlign, true);
        view.setUint16(32, blockAlign, true);
        view.setUint16(34, bytesPerSample * 8, true);
        writeString(view, 36, "data");
        view.setUint32(40, dataLength, true);

        let offset = 44;
        for (let i = 0; i < samples.length; i++, offset += 2) {
          let s = Math.max(-1, Math.min(1, samples[i]));
          s = s < 0 ? s * 0x8000 : s * 0x7fff;
          view.setInt16(offset, s, true);
        }

        return buffer;
      }

      function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      }

      function showResult(text) {
        result.className = "result";
        result.innerHTML = `
                <h3>‚úÖ –†–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è:</h3>
                <p>${text}</p>
            `;
      }

      function showError(message) {
        result.className = "result error";
        result.innerHTML = `
                <h3>‚ùå –û—à–∏–±–∫–∞:</h3>
                <p>${message}</p>
            `;
      }
    </script>
  </body>
</html>
